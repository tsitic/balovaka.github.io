<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
<title>Сапёр: △ ▢ ⬡ (проходимый)</title>
<style>
  :root{--bg:#0b0c10;--card:#12141a;--text:#e9eef5;--muted:#9aa5b1}
  html,body{margin:0;height:100%;background:var(--bg);color:var(--text);font-family:Inter,system-ui,Segoe UI,Arial}
  #ui{position:fixed;inset:0;display:grid;grid-template-rows:auto 1fr auto}
  header,footer{background:linear-gradient(180deg,rgba(255,255,255,.03),rgba(255,255,255,0));backdrop-filter:blur(6px)}
  header{display:flex;gap:10px;align-items:center;justify-content:space-between;padding:8px 12px;border-bottom:1px solid rgba(255,255,255,.08)}
  footer{display:flex;gap:10px;align-items:center;justify-content:center;padding:10px;border-top:1px solid rgba(255,255,255,.08)}
  .badge{background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.1);border-radius:10px;padding:6px 10px;font-weight:600}
  .btn{border:1px solid rgba(255,255,255,.12);background:rgba(255,255,255,.06);color:var(--text);padding:10px 12px;border-radius:12px;font-weight:700}
  .btn[data-active="1"]{outline:3px solid rgba(34,211,238,.25);border-color:rgba(34,211,238,.5)}
  .btn.primary{background:linear-gradient(180deg,rgba(34,211,238,.25),rgba(34,211,238,.08))}
  #canvas{display:block;width:100%;height:100%;touch-action:none;background:#0e1116}
  #menu{position:absolute;inset:0;display:flex;align-items:center;justify-content:center}
  #panel{max-width:720px;margin:16px;background:rgba(18,20,26,.9);border:1px solid rgba(255,255,255,.1);border-radius:16px;padding:16px}
  #panel h1{margin:.2rem 0 0;font-size:1.5rem}
  #panel .grid{display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-top:8px}
  #panel .grid button{padding:10px;border-radius:12px;border:1px solid rgba(255,255,255,.12);background:rgba(255,255,255,.06);color:var(--text);font-weight:700}
  #panel .grid button[data-active="1"]{outline:3px solid rgba(34,211,238,.25);border-color:rgba(34,211,238,.5)}
  #panel .actions{display:flex;gap:10px;justify-content:flex-end;margin-top:10px}
  .hint{color:var(--muted);font-size:.92rem;margin-top:8px}
</style>
</head>
<body>
<div id="ui">
  <header>
    <div>
      <span class="badge">Мины: <b id="mineCount">0</b></span>
      <span class="badge">Флаги: <b id="flagsLeft">0</b></span>
      <span class="badge">Открыто: <b id="openedCount">0</b></span>
      <span class="badge">Зум: <b id="zoom">100%</b></span>
    </div>
    <button class="btn" id="newBtn">Новая</button>
  </header>

  <main style="position:relative">
    <canvas id="canvas"></canvas>

    <div id="menu">
      <div id="panel">
        <h1>Сапёр (△ ▢ ⬡)</h1>
        <div class="hint">Выбери тесселяцию и сложность. Партии гарантированно решаемы логикой (без угадываний).</div>
        <div style="margin-top:10px;font-weight:700">Плитки</div>
        <div class="grid" id="shapeGrid">
          <button data-shape="tri" data-active="1">△ Треугольники</button>
          <button data-shape="sq">▢ Квадраты</button>
          <button data-shape="hex">⬡ Шестиугольники</button>
        </div>
        <div style="margin-top:10px;font-weight:700">Сложность</div>
        <div class="grid" id="diffGrid">
          <button data-diff="easy" data-active="1">Лёгкий</button>
          <button data-diff="norm">Обычный</button>
          <button data-diff="hard">Сложный</button>
        </div>
        <div class="actions">
          <button class="btn" id="startBtn">Старт</button>
        </div>
        <div class="hint">Режимы снизу: <b>Копать</b> • <b>Флаг</b> • <b>Перемещать</b>. Пинч/колёсико — масштаб.</div>
      </div>
    </div>
  </main>

  <footer>
    <button class="btn primary" id="modeDig" data-active="1">Копать</button>
    <button class="btn" id="modeFlag">Флаг</button>
    <button class="btn" id="modePan">Перемещать</button>
  </footer>
</div>

<script>
/* ========= утилиты ========= */
const rand=n=>Math.floor(Math.random()*n);
function shuffle(a){for(let i=a.length-1;i>0;i--){const j=rand(i+1);[a[i],a[j]]=[a[j],a[i]]}return a}
const clamp=(x,a,b)=>Math.max(a,Math.min(b,x));
function sample(arr,k){const c=arr.slice();shuffle(c);return c.slice(0,k);}

/* ========= пресеты ========= */
const PRESETS={
  tri:{ easy:{w:22,h:14,mineRatio:.11}, norm:{w:26,h:16,mineRatio:.13}, hard:{w:30,h:18,mineRatio:.15}, tileSize:40 },
  sq :{ easy:{w:14,h:10,mineRatio:.14}, norm:{w:18,h:12,mineRatio:.17}, hard:{w:22,h:14,mineRatio:.20}, tileSize:38 },
  hex:{ easy:{w:16,h:10,mineRatio:.14}, norm:{w:20,h:12,mineRatio:.17}, hard:{w:24,h:14,mineRatio:.20}, tileSize:28 }
};

/* ========= состояние ========= */
const canvas=document.getElementById('canvas'), ctx=canvas.getContext('2d');
let W=0,H=0;
let state=null; // {shape,w,h,size,cells[],mines}
let view={scale:1,ox:0,oy:0};
let mode='dig', running=false;

/* ========= индексация/соседи ========= */
const idx=(x,y,w)=>x+y*w, inside=(x,y,w,h)=>x>=0&&y>=0&&x<w&&y<h;

function neighbors(shape,x,y,w,h){
  if(shape==='sq'){
    const nn=[]; for(let dy=-1;dy<=1;dy++)for(let dx=-1;dx<=1;dx++){ if(dx||dy){const X=x+dx,Y=y+dy;if(inside(X,Y,w,h))nn.push(idx(X,Y,w));}}
    return nn;
  }
  if(shape==='hex'){ // flat-top, odd-q (смещение по столбцам)
    const odd=(x&1)===1;
    const cand = odd ? [[-1,0],[1,0],[0,-1],[1,-1],[0,1],[1,1]]
                     : [[-1,0],[1,0],[-1,-1],[0,-1],[-1,1],[0,1]];
    const nn=[]; for(const [dx,dy] of cand){const X=x+dx,Y=y+dy;if(inside(X,Y,w,h))nn.push(idx(X,Y,w));}
    return nn;
  }
  // tri: 3 соседа по ребру (ориентация по (x+y)%2)
  const up=((x+y)&1)===0, nn=[];
  const cand=up? [[0,-1],[-1,0],[1,0]] : [[0,1],[-1,0],[1,0]];
  for(const [dx,dy] of cand){const X=x+dx,Y=y+dy;if(inside(X,Y,w,h))nn.push(idx(X,Y,w));}
  return nn;
}

/* ========= генерация поля ========= */
function makeEmpty(w,h){return new Array(w*h).fill(0).map(()=>({mine:false,n:0,open:false,flag:false}))}
function placeMinesRandom(cells,w,h,count){const all=[];for(let y=0;y<h;y++)for(let x=0;x<w;x++)all.push(idx(x,y,w)); for(const i of sample(all,count))cells[i].mine=true;}
function recalcNumbers(shape,cells,w,h){
  for(let y=0;y<h;y++)for(let x=0;x<w;x++){
    const i=idx(x,y,w); if(cells[i].mine){cells[i].n=-1;continue;}
    let c=0; for(const j of neighbors(shape,x,y,w,h)) if(cells[j].mine) c++; cells[i].n=c;
  }
}

/* ========= солвер (логика без угадываний) ========= */
function floodOpen(shape,cells,w,h,start){
  const q=[start], seen=new Set([start]);
  while(q.length){
    const i=q.shift(); cells[i].open=true;
    if(cells[i].n===0){
      const x=i%w,y=(i/w)|0;
      for(const j of neighbors(shape,x,y,w,h)){
        if(!seen.has(j) && !cells[j].flag && !cells[j].mine){ seen.add(j); q.push(j); }
      }
    }
  }
}
function logicStep(shape,cells,w,h){
  let changed=false;
  for(let y=0;y<h;y++)for(let x=0;x<w;x++){
    const i=idx(x,y,w),C=cells[i]; if(!C.open||C.n<=0) continue;
    const adj=neighbors(shape,x,y,w,h);
    const closed=adj.filter(j=>!cells[j].open && !cells[j].flag);
    const flags =adj.filter(j=> cells[j].flag);
    if(flags.length===C.n && closed.length){
      for(const j of closed){ if(!cells[j].open){ floodOpen(shape,cells,w,h,j); changed=true; } }
    }else if(flags.length+closed.length===C.n && closed.length){
      for(const j of closed){ if(!cells[j].flag){ cells[j].flag=true; changed=true; } }
    }
  }
  return changed;
}
const isSolved=cells=>cells.every(c=>c.open||c.mine);
function trySolve(shape,cells,w,h){
  const tmp=cells.map(c=>({mine:c.mine,n:c.n,open:false,flag:false}));
  const start = tmp.findIndex(c=>!c.mine && c.n===0);
  if(start>=0) floodOpen(shape,tmp,w,h,start);
  else{ const any= tmp.findIndex(c=>!c.mine); if(any>=0) floodOpen(shape,tmp,w,h,any); }
  let guard=0; while(guard++<300){ if(!logicStep(shape,tmp,w,h)) break; }
  return isSolved(tmp);
}
function generateSolvable(shape,w,h,mineCount,maxTries=400){
  for(let t=0;t<maxTries;t++){
    const cells=makeEmpty(w,h);
    placeMinesRandom(cells,w,h,mineCount);
    recalcNumbers(shape,cells,w,h);
    if(trySolve(shape,cells,w,h)) return cells;
  }
  // fallback: чуть меньше мин
  const less=Math.max(1,Math.floor(mineCount*0.9));
  const cells=makeEmpty(w,h); placeMinesRandom(cells,w,h,less); recalcNumbers(shape,cells,w,h); return cells;
}

/* ========= геометрия (БЕЗ перекрытий) ========= */
/* квадраты — центр (x*S, y*S), r=S*0.5 */
function squarePoly(cx,cy,S){const r=S*0.5-1;return [[cx-r,cy-r],[cx+r,cy-r],[cx+r,cy+r],[cx-r,cy+r]];}

/* шестиугольник flat-top; радиус = S; шаги: dx=1.5S, dy=√3·S·(y+0.5*(x&1)) */
function hexCenter(x,y,S){
  const R=S, cx = x*(1.5*R), cy = Math.sqrt(3)*R*(y + 0.5*(x&1));
  return [cx,cy];
}
function hexPoly(cx,cy,R){const p=[];for(let k=0;k<6;k++){const a= Math.PI/3*k; p.push([cx+R*Math.cos(a), cy+R*Math.sin(a)]);}return p;}

/* треугольники: сторона a=S, высота h=√3/2·a; ровная сетка без наезда */
function triPolyByIndex(x,y,S){
  const a=S, h=a*Math.sqrt(3)/2;
  // базовая точка параллелограммной решётки
  const bx = x*(a/2), by = y*(h/2);
  const up = ((x+y)&1)===0;
  if(up)  return [[bx,by],[bx+a/2,by+h],[bx-a/2,by+h]];
  else    return [[bx,by+h],[bx+a/2,by],[bx-a/2,by]];
}
function centroid(poly){let x=0,y=0;for(const p of poly){x+=p[0];y+=p[1];}return [x/poly.length,y/poly.length];}

/* возврат полигона и "центра" для текста/иконок */
function getPoly(shape,x,y,S){
  if(shape==='sq'){
    const cx=x*S, cy=y*S; return {poly:squarePoly(cx,cy,S), center:[cx,cy]};
  }
  if(shape==='hex'){
    const [cx,cy]=hexCenter(x,y,S); return {poly:hexPoly(cx,cy,S-1), center:[cx,cy]};
  }
  const poly=triPolyByIndex(x,y,S); return {poly, center:centroid(poly)};
}

/* точный point-in-polygon */
function pip(px,py,poly){
  let inside=false; for(let i=0,j=poly.length-1;i<poly.length;j=i++){
    const [xi,yi]=poly[i],[xj,yj]=poly[j];
    const inter=((yi>py)!=(yj>py)) && (px < (xj-xi)*(py-yi)/(yj-yi+1e-9)+xi);
    if(inter) inside=!inside;
  } return inside;
}

/* ========= рендер ========= */
function resize(){
  canvas.width=canvas.clientWidth=window.innerWidth;
  const head=document.querySelector('header').offsetHeight;
  const foot=document.querySelector('footer').offsetHeight;
  canvas.height=canvas.clientHeight=window.innerHeight-head-foot;
  W=canvas.width; H=canvas.height; draw();
}
function draw(){
  ctx.clearRect(0,0,W,H);
  if(!state) return;
  ctx.save(); ctx.translate(view.ox,view.oy); ctx.scale(view.scale,view.scale);
  ctx.lineWidth=1/Math.max(1,view.scale);

  const {shape,w,h,size,cells}=state;
  for(let y=0;y<h;y++)for(let x=0;x<w;x++){
    const i=idx(x,y,w), C=cells[i], {poly,center:[cx,cy]}=getPoly(shape,x,y,size);

    ctx.beginPath(); pathPoly(poly);
    ctx.fillStyle=C.open?'rgba(255,255,255,.06)':'rgba(255,255,255,.02)'; ctx.fill();
    ctx.strokeStyle='rgba(255,255,255,.12)'; ctx.stroke();

    if(C.flag && !C.open){
      ctx.fillStyle='rgba(239,68,68,.9)'; drawFlag(cx,cy,Math.max(10,size*.22));
    }else if(C.open){
      if(C.mine){ ctx.fillStyle='rgba(239,68,68,.9)'; drawMine(cx,cy,Math.max(10,size*.22)); }
      else if(C.n>0){
        const color=['#93c5fd','#22d3ee','#22c55e','#eab308','#ef4444','#a855f7','#f97316','#38bdf8'][(C.n-1)%8];
        ctx.fillStyle=color; ctx.font=`${Math.max(10,size*.42)}px ui-monospace,Consolas,monospace`;
        ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText(String(C.n),cx,cy);
      }
    }
  }
  ctx.restore();
}
function pathPoly(poly){ctx.moveTo(poly[0][0],poly[0][1]); for(let k=1;k<poly.length;k++)ctx.lineTo(poly[k][0],poly[k][1]); ctx.closePath();}
function drawFlag(cx,cy,r){
  ctx.beginPath(); ctx.moveTo(cx-r*0.3,cy+r*0.6); ctx.lineTo(cx-r*0.3,cy-r*0.6);
  ctx.lineWidth=2/Math.max(1,view.scale); ctx.strokeStyle='rgba(255,255,255,.85)'; ctx.stroke();
  ctx.beginPath(); ctx.moveTo(cx-r*0.3,cy-r*0.55); ctx.lineTo(cx+r*0.7,cy-r*0.35); ctx.lineTo(cx-r*0.3,cy-r*0.15);
  ctx.closePath(); ctx.fill();
}
function drawMine(cx,cy,r){
  ctx.beginPath(); ctx.arc(cx,cy,r*0.7,0,Math.PI*2); ctx.fill();
  for(let k=0;k<8;k++){const a=Math.PI/4*k; ctx.beginPath(); ctx.moveTo(cx,cy); ctx.lineTo(cx+Math.cos(a)*r,cy+Math.sin(a)*r);
    ctx.strokeStyle='rgba(239,68,68,.9)'; ctx.lineWidth=2/Math.max(1,view.scale); ctx.stroke();}
}

/* ========= взаимодействие ========= */
function cellAtScreen(sx,sy){
  if(!state) return -1;
  const wx=(sx-view.ox)/view.scale, wy=(sy-view.oy)/view.scale;
  const {shape,w,h,size}=state;
  // быстрая проверка по bbox окрестности
  for(let y=0;y<h;y++)for(let x=0;x<w;x++){
    const i=idx(x,y,w), {poly}=getPoly(shape,x,y,size);
    // быстрый bbox
    let minx=1e9,miny=1e9,maxx=-1e9,maxy=-1e9;
    for(const [px,py] of poly){ if(px<minx)minx=px; if(py<miny)miny=py; if(px>maxx)maxx=px; if(py>maxy)maxy=py; }
    if(wx<minx||wx>maxx||wy<miny||wy>maxy) continue;
    if(pip(wx,wy,poly)) return i;
  }
  return -1;
}

function openCell(i){
  const c=state.cells[i]; if(!c||c.flag||c.open) return;
  if(c.mine){ state.cells.forEach(v=>v.open=true); running=false; draw(); alert('💥 Бум!'); return; }
  floodOpen(state.shape,state.cells,state.w,state.h,i);
  drawHUD(); draw(); checkWin();
}
function toggleFlag(i){ const c=state.cells[i]; if(!c||c.open) return; if(!c.flag && flagsLeft()<=0) return; c.flag=!c.flag; drawHUD(); draw(); }
const flagsLeft=()=>state.mines - state.cells.filter(c=>c.flag).length;
const openedCount=()=>state.cells.filter(c=>c.open).length;
function checkWin(){ if(state.cells.every(c=>c.open||c.mine)){ running=false; setTimeout(()=>alert('🎉 Победа!'),10);} }

canvas.addEventListener('wheel',e=>{
  e.preventDefault();
  const factor=Math.exp(-e.deltaY*0.001);
  zoomAt(e.offsetX,e.offsetY,factor);
},{passive:false});

let dragging=false, lastX=0,lastY=0;
canvas.addEventListener('pointerdown',e=>{ if(mode==='pan'){dragging=true; lastX=e.clientX; lastY=e.clientY; canvas.setPointerCapture(e.pointerId);} });
canvas.addEventListener('pointermove',e=>{ if(dragging){ view.ox+=e.clientX-lastX; view.oy+=e.clientY-lastY; lastX=e.clientX; lastY=e.clientY; draw(); }});
canvas.addEventListener('pointerup',()=>{dragging=false;});

canvas.addEventListener('touchstart',e=>{ if(e.touches.length===2){pinchPrev=touchDist(e);} },{passive:true});
let pinchPrev=0;
canvas.addEventListener('touchmove',e=>{
  if(e.touches.length===2){ e.preventDefault();
    const d=touchDist(e), factor=d/(pinchPrev||d); pinchPrev=d;
    const rect=canvas.getBoundingClientRect();
    const cx=(e.touches[0].clientX+e.touches[1].clientX)/2-rect.left;
    const cy=(e.touches[0].clientY+e.touches[1].clientY)/2-rect.top;
    zoomAt(cx,cy,factor);
  }
},{passive:false});
function touchDist(e){const [a,b]=[e.touches[0],e.touches[1]];return Math.hypot(a.clientX-b.clientX,a.clientY-b.clientY);}
function zoomAt(cx,cy,factor){
  const wx=(cx-view.ox)/view.scale, wy=(cy-view.oy)/view.scale;
  view.scale=clamp(view.scale*factor,.5,3.5);
  view.ox=cx-wx*view.scale; view.oy=cy-wy*view.scale;
  document.getElementById('zoom').textContent=Math.round(view.scale*100)+'%';
  draw();
}

canvas.addEventListener('click',e=>{
  if(!running||mode==='pan') return;
  const i=cellAtScreen(e.offsetX,e.offsetY); if(i<0) return;
  if(mode==='dig') openCell(i); else if(mode==='flag') toggleFlag(i);
});

/* ========= UI ========= */
const mineCountEl=document.getElementById('mineCount');
const flagsLeftEl=document.getElementById('flagsLeft');
const openedEl=document.getElementById('openedCount');
function drawHUD(){ mineCountEl.textContent=state.mines; flagsLeftEl.textContent=flagsLeft(); openedEl.textContent=openedCount(); }

document.getElementById('modeDig').onclick = ()=>setMode('dig');
document.getElementById('modeFlag').onclick= ()=>setMode('flag');
document.getElementById('modePan').onclick = ()=>setMode('pan');
function setMode(m){ mode=m;
  document.getElementById('modeDig').dataset.active=(m==='dig')?1:0;
  document.getElementById('modeFlag').dataset.active=(m==='flag')?1:0;
  document.getElementById('modePan').dataset.active=(m==='pan')?1:0;
}
document.getElementById('newBtn').onclick = ()=>{document.getElementById('menu').style.display='flex'; running=false;};

const shapeGrid=document.getElementById('shapeGrid'), diffGrid=document.getElementById('diffGrid');
let chosenShape='tri', chosenDiff='easy';
shapeGrid.addEventListener('click',e=>{const b=e.target.closest('button'); if(!b)return; chosenShape=b.dataset.shape; [...shapeGrid.children].forEach(x=>x.dataset.active=(x===b)?1:0);});
diffGrid.addEventListener('click',e=>{const b=e.target.closest('button'); if(!b)return; chosenDiff=b.dataset.diff;  [...diffGrid.children].forEach(x=>x.dataset.active=(x===b)?1:0);});
document.getElementById('startBtn').onclick=()=>{startGame(chosenShape,chosenDiff); document.getElementById('menu').style.display='none';};

function startGame(shape,diff){
  const p=PRESETS[shape], {w,h,mineRatio}=p[diff], S=p.tileSize;
  const mines=Math.max(1,Math.floor(w*h*mineRatio));
  const cells=generateSolvable(shape,w,h,mines);
  state={shape,w,h,size:S,mines,cells};
  // стартовый вид — слегка смещённый, чтобы поле вошло
  view.scale=1; view.ox=60; view.oy=60;
  running=true; setMode('dig'); drawHUD(); draw();
}

/* ========= init ========= */
function resizeAll(){resize();}
addEventListener('resize',resizeAll); resizeAll();
</script>
</body>
</html>
