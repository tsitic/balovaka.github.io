<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
<title>–°–∞–ø—ë—Ä: —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫–∏ ‚Ä¢ –∫–≤–∞–¥—Ä–∞—Ç—ã ‚Ä¢ —à–µ—Å—Ç–∏—É–≥–æ–ª—å–Ω–∏–∫–∏</title>
<style>
  :root{
    --bg:#0b0c10; --card:#12141a; --text:#e9eef5; --muted:#9aa5b1;
    --ok:#22c55e; --warn:#eab308; --bad:#ef4444; --cyan:#22d3ee;
  }
  html,body{margin:0;height:100%;background:var(--bg);color:var(--text);font-family:Inter,system-ui,Segoe UI,Arial}
  #ui{position:fixed;inset:0;display:grid;grid-template-rows:auto 1fr auto}
  header,footer{background:linear-gradient(180deg,rgba(255,255,255,0.03),rgba(255,255,255,0));backdrop-filter:blur(6px)}
  header{display:flex;gap:10px;align-items:center;justify-content:space-between;padding:8px 12px;border-bottom:1px solid rgba(255,255,255,.08)}
  footer{display:flex;gap:10px;align-items:center;justify-content:center;padding:10px;border-top:1px solid rgba(255,255,255,.08)}
  .badge{background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.1);border-radius:10px;padding:6px 10px;font-weight:600}
  .btn{border:1px solid rgba(255,255,255,.12);background:rgba(255,255,255,.06);color:var(--text);padding:10px 12px;border-radius:12px;font-weight:700}
  .btn[data-active="1"]{outline:3px solid rgba(34,211,238,.25);border-color:rgba(34,211,238,.5)}
  .btn.primary{background:linear-gradient(180deg,rgba(34,211,238,.25),rgba(34,211,238,.08))}
  .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  #canvas{display:block;width:100%;height:100%;touch-action:none;background:#0e1116}
  /* —Å—Ç–∞—Ä—Ç–æ–≤–æ–µ –º–µ–Ω—é */
  #menu{position:absolute;inset:0;display:flex;align-items:center;justify-content:center}
  #panel{max-width:720px;margin:16px;background:rgba(18,20,26,.9);border:1px solid rgba(255,255,255,.1);border-radius:16px;padding:16px}
  #panel h1{margin:.2rem 0 0;font-size:1.5rem}
  #panel .grid{display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-top:8px}
  #panel .grid button{padding:10px;border-radius:12px;border:1px solid rgba(255,255,255,.12);background:rgba(255,255,255,.06);color:var(--text);font-weight:700}
  #panel .grid button[data-active="1"]{outline:3px solid rgba(34,211,238,.25);border-color:rgba(34,211,238,.5)}
  #panel .actions{display:flex;gap:10px;justify-content:flex-end;margin-top:10px}
  .hint{color:var(--muted);font-size:.92rem;margin-top:8px}
</style>
</head>
<body>
<div id="ui">
  <header>
    <div class="row">
      <span class="badge">–ú–∏–Ω—ã: <b id="mineCount">0</b></span>
      <span class="badge">–§–ª–∞–≥–∏: <b id="flagsLeft">0</b></span>
      <span class="badge">–û—Ç–∫—Ä—ã—Ç–æ: <b id="openedCount">0</b></span>
      <span class="badge">–ú–∞—Å—à—Ç–∞–±: <b id="zoom">100%</b></span>
    </div>
    <div class="row">
      <button class="btn" id="newBtn">–ù–æ–≤–∞—è</button>
    </div>
  </header>

  <main style="position:relative">
    <canvas id="canvas"></canvas>

    <!-- –°—Ç–∞—Ä—Ç–æ–≤–æ–µ –º–µ–Ω—é -->
    <div id="menu">
      <div id="panel">
        <h1>–°–∞–ø—ë—Ä (–ø–ª–∏—Ç–∫–∏: ‚ñ≥ ‚ñ¢ ‚¨°)</h1>
        <div class="hint">1) –í—ã–±–µ—Ä–∏ —Ç–∏–ø –ø–ª–∏—Ç–æ–∫ (—Ç–µ—Å—Å–µ–ª—è—Ü–∏—è), 2) —Å–ª–æ–∂–Ω–æ—Å—Ç—å, 3) –°—Ç–∞—Ä—Ç. –ü–∞—Ä—Ç–∏—è –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç—Å—è —Ç–∞–∫, —á—Ç–æ–±—ã –µ—ë –º–æ–∂–Ω–æ –±—ã–ª–æ –ø—Ä–æ–π—Ç–∏ –±–µ–∑ —É–≥–∞–¥—ã–≤–∞–Ω–∏–π.</div>
        <div style="margin-top:10px;font-weight:700">–ü–ª–∏—Ç–∫–∏</div>
        <div class="grid" id="shapeGrid">
          <button data-shape="tri" data-active="1">‚ñ≥ –¢—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫–∏</button>
          <button data-shape="sq">‚ñ¢ –ö–≤–∞–¥—Ä–∞—Ç—ã</button>
          <button data-shape="hex">‚¨° –®–µ—Å—Ç–∏—É–≥–æ–ª—å–Ω–∏–∫–∏</button>
        </div>
        <div style="margin-top:10px;font-weight:700">–°–ª–æ–∂–Ω–æ—Å—Ç—å</div>
        <div class="grid" id="diffGrid">
          <button data-diff="easy"  data-active="1">–õ—ë–≥–∫–∏–π</button>
          <button data-diff="norm">–û–±—ã—á–Ω—ã–π</button>
          <button data-diff="hard">–°–ª–æ–∂–Ω—ã–π</button>
        </div>
        <div class="actions">
          <button class="btn" id="startBtn">–°—Ç–∞—Ä—Ç</button>
        </div>
        <div class="hint">–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –≤ –∏–≥—Ä–µ: —Ä–µ–∂–∏–º—ã –≤–Ω–∏–∑—É ‚Äî <b>–ö–æ–ø–∞—Ç—å</b>, <b>–§–ª–∞–≥</b>, <b>–ü–µ—Ä–µ–º–µ—â–∞—Ç—å</b>. –ü–∏–Ω—á –¥–ª—è –º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏—è, –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏–µ –≤ —Ä–µ–∂–∏–º–µ ¬´–ü–µ—Ä–µ–º–µ—â–∞—Ç—å¬ª.</div>
      </div>
    </div>
  </main>

  <footer>
    <button class="btn primary" id="modeDig"   data-active="1">–ö–æ–ø–∞—Ç—å</button>
    <button class="btn"         id="modeFlag">–§–ª–∞–≥</button>
    <button class="btn"         id="modePan">–ü–µ—Ä–µ–º–µ—â–∞—Ç—å</button>
  </footer>
</div>

<script>
/* =========================== –£–¢–ò–õ–ò–¢–´ ============================ */
const rand = (n)=>Math.floor(Math.random()*n);
const clamp=(x,a,b)=>Math.max(a,Math.min(b,x));
function shuffle(a){for(let i=a.length-1;i>0;i--){const j=rand(i+1);[a[i],a[j]]=[a[j],a[i]];}return a;}
function sample(arr,k){const c=arr.slice();shuffle(c);return c.slice(0,k);}

/* ===================== –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Ø –†–ê–ó–ú–ï–†–û–í ===================== */
/* –ó–Ω–∞—á–µ–Ω–∏—è –ø–æ–¥–æ–±—Ä–∞–Ω—ã, —á—Ç–æ–±—ã —Å–æ–ª–≤–µ—Ä –±—ã—Å—Ç—Ä–æ –Ω–∞—Ö–æ–¥–∏–ª –ø—Ä–æ—Ö–æ–¥–∏–º—ã–µ –ø–æ–ª—è */
const PRESETS = {
  tri: {
    easy:  {w:22,h:16, mineRatio:0.11},
    norm:  {w:26,h:18, mineRatio:0.13},
    hard:  {w:30,h:20, mineRatio:0.15},
    tileSize: 34
  },
  sq: {
    easy:  {w:14,h:10, mineRatio:0.14},
    norm:  {w:18,h:12, mineRatio:0.17},
    hard:  {w:22,h:14, mineRatio:0.20},
    tileSize: 36
  },
  hex: {
    easy:  {w:16,h:10, mineRatio:0.14},
    norm:  {w:20,h:12, mineRatio:0.17},
    hard:  {w:24,h:14, mineRatio:0.20},
    tileSize: 34
  }
};

/* =================== –ì–õ–û–ë–ê–õ–¨–ù–û–ï –°–û–°–¢–û–Ø–ù–ò–ï –ò–ì–†–´ =================== */
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
let W=0,H=0;
let state=null;     // {shape, w,h, mines, cells[], opened, flags}
let view={scale:1, ox:0, oy:0}; // –ø–∞–Ω–æ—Ä–∞–º–∏—Ä–æ–≤–∞–Ω–∏–µ/–º–∞—Å—à—Ç–∞–±
let mode='dig';     // 'dig' | 'flag' | 'pan'
let running=false;

/* ====================== –í–°–ü–û–ú–û–ì–ê–¢–ï–õ–¨–ù–ê–Ø –ú–ê–¢–ï–ú–ê–¢–ò–ö–ê ===================== */
/* –ò–Ω–¥–µ–∫—Å–∞—Ü–∏—è –∫–ª–µ—Ç–æ–∫: i = x + y*w */
const idx=(x,y,w)=>x+y*w;
const inside=(x,y,w,h)=>x>=0&&y>=0&&x<w&&y<h;

/* –°–æ—Å–µ–¥—Å—Ç–≤–∞ –¥–ª—è —Ä–∞–∑–Ω—ã—Ö —Ç–µ—Å—Å–µ–ª—è—Ü–∏–π
   tri: —É—á–∏—Ç—ã–≤–∞–µ–º —Å–æ—Å–µ–¥–µ–π –ø–æ –†–ï–ë–†–£ (3 —à—Ç—É–∫–∏), –æ—Ä–∏–µ–Ω—Ç–∞—Ü–∏—è –∑–∞–≤–∏—Å–∏—Ç –æ—Ç (x+y)%2
   sq : 8-—Å–æ—Å–µ–¥–µ–π (–∫–ª–∞—Å—Å–∏–∫–∞ —Å–∞–ø—ë—Ä–∞)
   hex: 6-—Å–æ—Å–µ–¥–µ–π –≤ ¬´—á—ë—Ç–Ω–æ-—Å–º–µ—â—ë–Ω–Ω–æ–π¬ª —Å–µ—Ç–∫–µ (offset coords)
*/
function neighbors(shape,x,y,w,h){
  const nn=[];
  if(shape==='sq'){
    for(let dy=-1;dy<=1;dy++)for(let dx=0-1;dx<=1;dx++){
      if(dx===0&&dy===0)continue;
      const X=x+dx,Y=y+dy;
      if(inside(X,Y,w,h)) nn.push(idx(X,Y,w));
    }
  }else if(shape==='tri'){
    const up = ((x+y)&1)===0; // —á—ë—Ç–Ω–æ—Å—Ç—å ‚Äî –æ—Ä–∏–µ–Ω—Ç–∞—Ü–∏—è —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫–∞
    const candidates = up
      ? [[0,-1],[-1,0],[1,0]]
      : [[0,1],[-1,0],[1,0]];
    for(const [dx,dy] of candidates){
      const X=x+dx,Y=y+dy;
      if(inside(X,Y,w,h)) nn.push(idx(X,Y,w));
    }
  }else if(shape==='hex'){
    // —á—ë—Ç–Ω–æ-—Å–º–µ—â—ë–Ω–Ω—ã–µ —Ä—è–¥—ã (¬´even-q¬ª)
    const even = (y&1)===0;
    const cand = even
      ? [[-1,0],[1,0],[0,-1],[1,-1],[0,1],[1,1]]
      : [[-1,0],[1,0],[-1,-1],[0,-1],[-1,1],[0,1]];
    for(const [dx,dy] of cand){
      const X=x+dx,Y=y+dy;
      if(inside(X,Y,w,h)) nn.push(idx(X,Y,w));
    }
  }
  return nn;
}

/* ========================= –ì–ï–ù–ï–†–ê–¶–ò–Ø –ü–û–õ–Ø ========================= */
/* –°—Ç—Ä—É–∫—Ç—É—Ä–∞ cell: {mine:boolean, n:number, open:boolean, flag:boolean} */
function makeEmpty(w,h){
  return new Array(w*h).fill(0).map(()=>({mine:false,n:0,open:false,flag:false}));
}
function placeMinesRandom(cells,w,h,count){
  const all=[];
  for(let y=0;y<h;y++)for(let x=0;x<w;x++)all.push(idx(x,y,w));
  const mines = sample(all,count);
  for(const i of mines) cells[i].mine=true;
}
function recalcNumbers(shape,cells,w,h){
  for(let y=0;y<h;y++)for(let x=0;x<w;x++){
    const i=idx(x,y,w); if(cells[i].mine){cells[i].n=-1;continue;}
    let c=0; for(const j of neighbors(shape,x,y,w,h)) if(cells[j].mine) c++;
    cells[i].n=c;
  }
}

/* ===================== –õ–û–ì–ò–ß–ï–°–ö–ò–ô –°–û–õ–í–ï–† (–î–ï–¢–û–ö–°) ===================== */
/* –ë–∞–∑–æ–≤—ã–µ –ø—Ä–∞–≤–∏–ª–∞:
   1) –ï—Å–ª–∏ —Ü–∏—Ñ—Ä–∞ = –∫–æ–ª-–≤–æ —Ñ–ª–∞–≥–æ–≤ —Ä—è–¥–æ–º ‚Üí –æ—Ç–∫—Ä—ã—Ç—å –≤—Å–µ –æ—Å—Ç–∞–ª—å–Ω—ã–µ –∑–∞–∫—Ä—ã—Ç—ã–µ.
   2) –ï—Å–ª–∏ —Ü–∏—Ñ—Ä–∞ = –∫–æ–ª-–≤–æ –∑–∞–∫—Ä—ã—Ç—ã—Ö —Ä—è–¥–æ–º ‚Üí –ø–æ–º–µ—Ç–∏—Ç—å –∏—Ö —Ñ–ª–∞–∂–∫–∞–º–∏.
   –¢–∞–∫–∂–µ –≤—ã–ø–æ–ª–Ω—è–µ–º flood-fill –¥–ª—è –Ω—É–ª–µ–π.
   –ì–µ–Ω–µ—Ä–∞—Ç–æ—Ä –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫–∞–µ—Ç –∫–∞—Ä—Ç—É, –ø–æ–∫–∞ —ç—Ç–æ—Ç —Å–æ–ª–≤–µ—Ä –Ω–µ —Ä–∞—Å–∫—Ä–æ–µ—Ç –≤—Å—ë –±–µ–∑–æ–ø–∞—Å–Ω–æ–µ.
*/
function floodOpen(shape,cells,w,h,start){
  const q=[start]; const seen=new Set([start]);
  while(q.length){
    const i=q.shift(); const x=i%w, y=(i/w)|0;
    cells[i].open=true;
    if(cells[i].n===0){
      for(const j of neighbors(shape,x,y,w,h)){
        if(!seen.has(j) && !cells[j].flag && !cells[j].mine){
          seen.add(j); q.push(j);
        }
      }
    }
  }
}

function logicStep(shape,cells,w,h){
  let changed=false;
  for(let y=0;y<h;y++)for(let x=0;x<w;x++){
    const i=idx(x,y,w), C=cells[i];
    if(!C.open || C.n<=0) continue;
    const adj=neighbors(shape,x,y,w,h);
    const closed=adj.filter(j=>!cells[j].open && !cells[j].flag);
    const flags =adj.filter(j=>cells[j].flag);
    if(flags.length===C.n && closed.length>0){
      // –≤—Å–µ –æ—Å—Ç–∞–ª—å–Ω—ã–µ –±–µ–∑–æ–ø–∞—Å–Ω—ã
      for(const j of closed){ if(!cells[j].open){ floodOpen(shape,cells,w,h,j); changed=true; } }
    }else if(flags.length+closed.length===C.n && closed.length>0){
      // –≤—Å–µ –∑–∞–∫—Ä—ã—Ç—ã–µ ‚Äî –º–∏–Ω—ã
      for(const j of closed){ if(!cells[j].flag){ cells[j].flag=true; changed=true; } }
    }
  }
  return changed;
}

function isSolved(cells){ return cells.every(c=> c.open || c.mine); }

/* –ü–æ–ø—ã—Ç–∫–∞ –∞–≤—Ç–æ—Å–æ–ª–≤–∞ –∫–∞—Ä—Ç—ã (–∫–æ–ø–∏—Ä—É–µ—Ç –º–∞—Å—Å–∏–≤, –Ω–µ —Ç—Ä–æ–≥–∞–µ—Ç ¬´–±–æ–µ–≤–æ–µ¬ª —Å–æ—Å—Ç–æ—è–Ω–∏–µ) */
function trySolve(shape,cells,w,h){
  const tmp=cells.map(c=>({mine:c.mine,n:c.n,open:false,flag:false}));
  // —Å—Ç–∞—Ä—Ç: —Ä–∞—Å–∫—Ä—ã–≤–∞–µ–º –ª—é–±—É—é –±–µ–∑–æ–ø–∞—Å–Ω—É—é –Ω—É–ª–µ–≤—É—é (–∏–ª–∏ –±–ª–∏–∂–∞–π—à—É—é –∫ –Ω–µ–π)
  // –Ω–∞–π–¥—ë–º –∫–ª–µ—Ç–∫—É —Å n==0 (–µ—Å–ª–∏ –µ—Å—Ç—å)
  let startIndex = tmp.findIndex(c=>!c.mine && c.n===0);
  if(startIndex<0){
    // –Ω–µ—Ç –Ω—É–ª–µ–π, –æ—Ç–∫—Ä–æ–µ–º —Å–ª—É—á–∞–π–Ω—É—é –±–µ–∑–æ–ø–∞—Å–Ω—É—é –∏ –ø–æ–ø—ã—Ç–∞–µ–º —Å—á–∞—Å—Ç—å–µ
    const safeIdx = tmp.findIndex(c=>!c.mine);
    if(safeIdx>=0) floodOpen(shape,tmp,w,h,safeIdx);
  }else{
    floodOpen(shape,tmp,w,h,startIndex);
  }
  // –ø—Ä–∏–º–µ–Ω—è–µ–º –ø—Ä–∞–≤–∏–ª–∞ –¥–æ —Å—Ç–∞–≥–Ω–∞—Ü–∏–∏
  let guard=0;
  while(guard++<200){
    if(!logicStep(shape,tmp,w,h)) break;
  }
  return isSolved(tmp);
}

/* –°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –ø–æ–ª–µ, –ø–æ–∫–∞ —Å–æ–ª–≤–µ—Ä –Ω–µ –ø—Ä–æ–π–¥—ë—Ç */
function generateSolvable(shape,w,h,mineCount,maxTries=300){
  for(let t=0;t<maxTries;t++){
    const cells=makeEmpty(w,h);
    placeMinesRandom(cells,w,h,mineCount);
    recalcNumbers(shape,cells,w,h);
    if(trySolve(shape,cells,w,h)) return cells;
  }
  // –ï—Å–ª–∏ –≤–¥—Ä—É–≥ –Ω–µ —É–¥–∞–ª–æ—Å—å ‚Äî —É–º–µ–Ω—å—à–∏–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –º–∏–Ω –∏ –ø–æ–ø—Ä–æ–±—É–µ–º –µ—â—ë
  const less = Math.max(1, Math.floor(mineCount*0.9));
  const cells=makeEmpty(w,h);
  placeMinesRandom(cells,w,h,less);
  recalcNumbers(shape,cells,w,h);
  return cells;
}

/* ============================ –†–ï–ù–î–ï–† ============================ */
function resize(){
  canvas.width = canvas.clientWidth = window.innerWidth;
  canvas.height= canvas.clientHeight= window.innerHeight - document.querySelector('header').offsetHeight - document.querySelector('footer').offsetHeight;
  W=canvas.width; H=canvas.height; draw();
}

function worldToScreen(x,y){ return [x*view.scale+view.ox, y*view.scale+view.oy]; }
function screenToWorld(sx,sy){ return [(sx-view.ox)/view.scale, (sy-view.oy)/view.scale]; }

function draw(){
  ctx.clearRect(0,0,W,H);
  if(!state) return;
  const {shape,w,h,cells,size} = state;

  ctx.save();
  ctx.translate(view.ox,view.oy);
  ctx.scale(view.scale,view.scale);

  ctx.lineWidth = 1/Math.max(1,view.scale);

  for(let y=0;y<h;y++)for(let x=0;x<w;x++){
    const i=idx(x,y,w), c=cells[i];
    drawTile(shape,x,y,size, c);
  }
  ctx.restore();
}

function drawTile(shape,x,y,S,c){
  // —Ü–µ–Ω—Ç—Ä –∏ –∫–æ–Ω—Ç—É—Ä –ø–æ —Ñ–æ—Ä–º–µ
  let poly=[];
  let cx=0, cy=0;
  if(shape==='sq'){
    cx = x*S*1.05; cy = y*S*1.05;
    poly = squarePoly(cx,cy,S);
  }else if(shape==='hex'){
    const off = (y&1)? S*0.87 : 0;
    cx = x*(S*1.74)+off; cy = y*(S*1.5);
    poly = hexPoly(cx,cy,S*0.95);
  }else{ // tri
    cx = x*(S*0.95); cy = y*(S*0.82);
    const up = ((x+y)&1)===0;
    poly = triPoly(cx,cy,S,up);
  }

  // —Ñ–æ–Ω –∫–ª–µ—Ç–∫–∏
  ctx.beginPath(); polyPath(poly);
  ctx.fillStyle = c.open ? 'rgba(255,255,255,0.05)' : 'rgba(255,255,255,0.02)';
  ctx.fill();
  ctx.strokeStyle='rgba(255,255,255,0.12)'; ctx.stroke();

  // —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ
  if(c.flag && !c.open){
    // —Ñ–ª–∞–≥
    ctx.fillStyle = 'rgba(239,68,68,0.9)';
    drawFlag(cx,cy,Math.max(10,S*0.22));
  }else if(c.open){
    if(c.mine){
      ctx.fillStyle='rgba(239,68,68,0.9)';
      drawMine(cx,cy,Math.max(10,S*0.22));
    }else if(c.n>0){
      ctx.fillStyle='white';
      ctx.font = `${Math.max(10,S*0.38)}px/1.0 ui-monospace,Consolas,monospace`;
      ctx.textAlign='center'; ctx.textBaseline='middle';
      const colorByNum=['#9aa5b1','#22d3ee','#22c55e','#eab308','#ef4444','#a855f7','#f97316','#38bdf8'];
      ctx.fillStyle = colorByNum[(c.n-1)%colorByNum.length];
      ctx.fillText(String(c.n), cx, cy);
    }
  }
}

function polyPath(poly){ ctx.moveTo(poly[0][0],poly[0][1]); for(let k=1;k<poly.length;k++) ctx.lineTo(poly[k][0],poly[k][1]); ctx.closePath(); }
function squarePoly(cx,cy,S){ const r=S*0.48; return [[cx-r,cy-r],[cx+r,cy-r],[cx+r,cy+r],[cx-r,cy+r]]; }
function hexPoly(cx,cy,R){
  const p=[]; for(let k=0;k<6;k++){ const a=Math.PI/3*k; p.push([cx+R*Math.cos(a), cy+R*Math.sin(a)]);} return p;
}
function triPoly(cx,cy,S,up){
  const r=S*0.55, h=r*Math.sqrt(3)/2;
  if(up) return [[cx,cy-h],[cx-r/1.1,cy+h],[cx+r/1.1,cy+h]];
  else   return [[cx,cy+h],[cx-r/1.1,cy-h],[cx+r/1.1,cy-h]];
}
function drawFlag(cx,cy,r){
  ctx.beginPath(); ctx.moveTo(cx-r*0.3,cy+r*0.6); ctx.lineTo(cx-r*0.3,cy-r*0.6); ctx.lineWidth=2/Math.max(1,view.scale); ctx.strokeStyle='rgba(255,255,255,0.8)'; ctx.stroke();
  ctx.beginPath(); ctx.moveTo(cx-r*0.3,cy-r*0.55); ctx.lineTo(cx+r*0.7,cy-r*0.35); ctx.lineTo(cx-r*0.3,cy-r*0.15); ctx.closePath(); ctx.fill();
}
function drawMine(cx,cy,r){
  ctx.beginPath(); ctx.arc(cx,cy,r*0.7,0,Math.PI*2); ctx.fill();
  for(let k=0;k<8;k++){ const a=Math.PI/4*k; ctx.beginPath(); ctx.moveTo(cx,cy); ctx.lineTo(cx+Math.cos(a)*r,cy+Math.sin(a)*r); ctx.strokeStyle='rgba(239,68,68,0.9)'; ctx.lineWidth=2/Math.max(1,view.scale); ctx.stroke(); }
}

/* ============================ –í–ó–ê–ò–ú–û–î–ï–ô–°–¢–í–ò–ï ============================ */
function cellAtScreen(sx,sy){
  if(!state) return -1;
  const {shape,w,h,size}=state;
  const [wx,wy]=screenToWorld(sx,sy);
  // –±—ã—Å—Ç—Ä—ã–π –ø–æ–∏—Å–∫ –ø–æ —Å–µ—Ç–∫–µ: –ø–µ—Ä–µ–±–µ—Ä—ë–º –æ–∫—Ä–µ—Å—Ç–Ω–æ—Å—Ç—å
  let best=-1, bestD=1e9;
  for(let y=0;y<h;y++)for(let x=0;x<w;x++){
    // –ø–µ—Ä–µ–∏—Å–ø–æ–ª—å–∑—É–µ–º —Ü–µ–Ω—Ç—Ä—ã –∫–∞–∫ –≤ drawTile
    let cx=0,cy=0;
    if(shape==='sq'){ cx=x*size*1.05; cy=y*size*1.05; }
    else if(shape==='hex'){ const off=(y&1)? size*0.87:0; cx=x*(size*1.74)+off; cy=y*(size*1.5); }
    else { cx=x*(size*0.95); cy=y*(size*0.82); }
    const dx=wx-cx, dy=wy-cy, d=dx*dx+dy*dy;
    if(d<bestD){ bestD=d; best=idx(x,y,state.w); }
  }
  return best;
}

function openCell(i){
  const c=state.cells[i]; if(c.flag||c.open) return;
  if(c.mine){ // –ø—Ä–æ–∏–≥—Ä—ã—à ‚Äî –æ—Ç–∫—Ä–æ–µ–º –≤—Å–µ, –ø–æ–∫–∞–∂–µ–º –º–∏–Ω—ã
    state.cells.forEach(cc=>cc.open=true);
    running=false; draw();
    alert('üí• –ë—É–º! –ü–æ–ø—Ä–æ–±—É–π –µ—â—ë —Ä–∞–∑ ‚Äî –ù–æ–≤–∞—è –ø–∞—Ä—Ç–∏—è –≥–∞—Ä–∞–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ –ø—Ä–æ—Ö–æ–¥–∏–º–∞.');
    return;
  }
  floodOpen(state.shape,state.cells,state.w,state.h,i);
  drawHUD();
  draw();
  checkWin();
}

function toggleFlag(i){
  const c=state.cells[i]; if(c.open) return;
  if(!c.flag && flagsLeft()<=0) return;
  c.flag=!c.flag; drawHUD(); draw();
}

function flagsLeft(){ return state.mines - state.cells.filter(c=>c.flag).length; }
function openedCount(){ return state.cells.filter(c=>c.open).length; }

function checkWin(){
  if(state.cells.every(c=>c.open || c.mine)){
    running=false; draw();
    setTimeout(()=>alert('üéâ –ü–æ–±–µ–¥–∞!'),10);
  }
}

/* =========== –ü–∞–Ω–æ—Ä–∞–º–∏—Ä–æ–≤–∞–Ω–∏–µ –∏ –º–∞—Å—à—Ç–∞–± (–∫–æ–ª–µ—Å–æ/–ø–∏–Ω—á/–ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏–µ) =========== */
canvas.addEventListener('wheel',(e)=>{
  e.preventDefault();
  const scale0=view.scale;
  const delta = -e.deltaY;
  const factor = Math.exp(delta*0.001); // –ø–ª–∞–≤–Ω–æ
  const rect=canvas.getBoundingClientRect();
  const cx=e.clientX-rect.left, cy=e.clientY-rect.top;
  zoomAt(cx,cy,factor);
},{passive:false});

let dragging=false, lastX=0,lastY=0;
canvas.addEventListener('pointerdown', (e)=>{
  if(mode==='pan'){ dragging=true; lastX=e.clientX; lastY=e.clientY; canvas.setPointerCapture(e.pointerId); }
});
canvas.addEventListener('pointermove', (e)=>{
  if(dragging){ view.ox += (e.clientX-lastX); view.oy += (e.clientY-lastY); lastX=e.clientX; lastY=e.clientY; draw(); }
});
canvas.addEventListener('pointerup',   ()=>{dragging=false;});

/* –ü–∏–Ω—á */
let touchIds=[];
let pinchPrevDist=0;
canvas.addEventListener('touchstart', (e)=>{
  if(e.touches.length===2){
    touchIds=[e.touches[0].identifier, e.touches[1].identifier];
    pinchPrevDist = distTouches(e);
  }
},{passive:true});
canvas.addEventListener('touchmove', (e)=>{
  if(e.touches.length===2 && touchIds.every(id=>[...e.touches].some(t=>t.identifier===id))){
    e.preventDefault();
    const d = distTouches(e);
    const factor = d/pinchPrevDist;
    pinchPrevDist=d;
    const rect=canvas.getBoundingClientRect();
    const cx=(e.touches[0].clientX+e.touches[1].clientX)/2-rect.left;
    const cy=(e.touches[0].clientY+e.touches[1].clientY)/2-rect.top;
    zoomAt(cx,cy,factor);
  }
},{passive:false});
function distTouches(e){
  const [a,b]=[e.touches[0],e.touches[1]];
  const dx=a.clientX-b.clientX, dy=a.clientY-b.clientY; return Math.hypot(dx,dy);
}
function zoomAt(cx,cy,factor){
  const prev=view.scale;
  view.scale=clamp(prev*factor,0.5,3.5);
  const [wx,wy]=screenToWorld(cx,cy);
  view.ox = cx - wx*view.scale;
  view.oy = cy - wy*view.scale;
  document.getElementById('zoom').textContent = Math.round(view.scale*100)+'%';
  draw();
}

/* –ö–ª–∏–∫–∏/—Ç–∞–ø—ã –ø–æ –ø–æ–ª—é */
canvas.addEventListener('click',(e)=>{
  if(!running || mode==='pan') return;
  const rect=canvas.getBoundingClientRect();
  const i=cellAtScreen(e.clientX-rect.left,e.clientY-rect.top);
  if(i<0) return;
  if(mode==='dig') openCell(i);
  else if(mode==='flag') toggleFlag(i);
});

/* ====================== UI –ö–ù–û–ü–ö–ò –ò –ú–ï–ù–Æ ====================== */
const mineCountEl=document.getElementById('mineCount');
const flagsLeftEl=document.getElementById('flagsLeft');
const openedEl=document.getElementById('openedCount');
function drawHUD(){
  mineCountEl.textContent = state.mines;
  flagsLeftEl.textContent = flagsLeft();
  openedEl.textContent = openedCount();
}

document.getElementById('modeDig').onclick = ()=>setMode('dig');
document.getElementById('modeFlag').onclick= ()=>setMode('flag');
document.getElementById('modePan').onclick = ()=>setMode('pan');
function setMode(m){
  mode=m;
  document.getElementById('modeDig').dataset.active = (m==='dig')?1:0;
  document.getElementById('modeFlag').dataset.active= (m==='flag')?1:0;
  document.getElementById('modePan').dataset.active = (m==='pan')?1:0;
}

document.getElementById('newBtn').onclick = ()=>{ document.getElementById('menu').style.display='flex'; running=false; };

const shapeGrid=document.getElementById('shapeGrid');
const diffGrid =document.getElementById('diffGrid');
let chosenShape='tri', chosenDiff='easy';
shapeGrid.addEventListener('click',(e)=>{
  const b=e.target.closest('button'); if(!b) return;
  chosenShape=b.dataset.shape;
  [...shapeGrid.children].forEach(x=>x.dataset.active = (x===b)?1:0);
});
diffGrid.addEventListener('click',(e)=>{
  const b=e.target.closest('button'); if(!b) return;
  chosenDiff=b.dataset.diff;
  [...diffGrid.children].forEach(x=>x.dataset.active = (x===b)?1:0);
});

document.getElementById('startBtn').onclick = ()=>{
  startGame(chosenShape, chosenDiff);
  document.getElementById('menu').style.display='none';
};

function startGame(shape,diff){
  const preset = PRESETS[shape];
  const {w,h,mineRatio}=preset[diff];
  const S = preset.tileSize;
  const mines = Math.max(1, Math.floor(w*h*mineRatio));
  const cells = generateSolvable(shape,w,h,mines);
  state={shape,w,h,mines,cells,size:S};
  // —Å–±—Ä–æ—Å –≤–∏–¥–∞, —Ü–µ–Ω—Ç—Ä–∏—Ä—É–µ–º –ø–æ–ª–µ
  view.scale=1; view.ox=W/2 - (w* S)*0.4; view.oy=H/2 - (h* S)*0.4;
  running=true; setMode('dig'); drawHUD(); draw();
}

/* ========================= –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø ========================= */
resize(); addEventListener('resize', resize);
</script>
</body>
</html>
