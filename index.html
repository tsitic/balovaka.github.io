<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
<title>Сапёр: треугольники • квадраты • шестиугольники</title>
<style>
  :root{
    --bg:#0b0c10; --card:#12141a; --text:#e9eef5; --muted:#9aa5b1;
    --ok:#22c55e; --warn:#eab308; --bad:#ef4444; --cyan:#22d3ee;
  }
  html,body{margin:0;height:100%;background:var(--bg);color:var(--text);font-family:Inter,system-ui,Segoe UI,Arial}
  #ui{position:fixed;inset:0;display:grid;grid-template-rows:auto 1fr auto}
  header,footer{background:linear-gradient(180deg,rgba(255,255,255,0.03),rgba(255,255,255,0));backdrop-filter:blur(6px)}
  header{display:flex;gap:10px;align-items:center;justify-content:space-between;padding:8px 12px;border-bottom:1px solid rgba(255,255,255,.08)}
  footer{display:flex;gap:10px;align-items:center;justify-content:center;padding:10px;border-top:1px solid rgba(255,255,255,.08)}
  .badge{background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.1);border-radius:10px;padding:6px 10px;font-weight:600}
  .btn{border:1px solid rgba(255,255,255,.12);background:rgba(255,255,255,.06);color:var(--text);padding:10px 12px;border-radius:12px;font-weight:700}
  .btn[data-active="1"]{outline:3px solid rgba(34,211,238,.25);border-color:rgba(34,211,238,.5)}
  .btn.primary{background:linear-gradient(180deg,rgba(34,211,238,.25),rgba(34,211,238,.08))}
  .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  #canvas{display:block;width:100%;height:100%;touch-action:none;background:#0e1116}
  /* стартовое меню */
  #menu{position:absolute;inset:0;display:flex;align-items:center;justify-content:center}
  #panel{max-width:720px;margin:16px;background:rgba(18,20,26,.9);border:1px solid rgba(255,255,255,.1);border-radius:16px;padding:16px}
  #panel h1{margin:.2rem 0 0;font-size:1.5rem}
  #panel .grid{display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-top:8px}
  #panel .grid button{padding:10px;border-radius:12px;border:1px solid rgba(255,255,255,.12);background:rgba(255,255,255,.06);color:var(--text);font-weight:700}
  #panel .grid button[data-active="1"]{outline:3px solid rgba(34,211,238,.25);border-color:rgba(34,211,238,.5)}
  #panel .actions{display:flex;gap:10px;justify-content:flex-end;margin-top:10px}
  .hint{color:var(--muted);font-size:.92rem;margin-top:8px}
</style>
</head>
<body>
<div id="ui">
  <header>
    <div class="row">
      <span class="badge">Мины: <b id="mineCount">0</b></span>
      <span class="badge">Флаги: <b id="flagsLeft">0</b></span>
      <span class="badge">Открыто: <b id="openedCount">0</b></span>
      <span class="badge">Масштаб: <b id="zoom">100%</b></span>
    </div>
    <div class="row">
      <button class="btn" id="newBtn">Новая</button>
    </div>
  </header>

  <main style="position:relative">
    <canvas id="canvas"></canvas>

    <!-- Стартовое меню -->
    <div id="menu">
      <div id="panel">
        <h1>Сапёр (плитки: △ ▢ ⬡)</h1>
        <div class="hint">1) Выбери тип плиток (тесселяция), 2) сложность, 3) Старт. Партия генерируется так, чтобы её можно было пройти без угадываний.</div>
        <div style="margin-top:10px;font-weight:700">Плитки</div>
        <div class="grid" id="shapeGrid">
          <button data-shape="tri" data-active="1">△ Треугольники</button>
          <button data-shape="sq">▢ Квадраты</button>
          <button data-shape="hex">⬡ Шестиугольники</button>
        </div>
        <div style="margin-top:10px;font-weight:700">Сложность</div>
        <div class="grid" id="diffGrid">
          <button data-diff="easy"  data-active="1">Лёгкий</button>
          <button data-diff="norm">Обычный</button>
          <button data-diff="hard">Сложный</button>
        </div>
        <div class="actions">
          <button class="btn" id="startBtn">Старт</button>
        </div>
        <div class="hint">Управление в игре: режимы внизу — <b>Копать</b>, <b>Флаг</b>, <b>Перемещать</b>. Пинч для масштабирования, перетаскивание в режиме «Перемещать».</div>
      </div>
    </div>
  </main>

  <footer>
    <button class="btn primary" id="modeDig"   data-active="1">Копать</button>
    <button class="btn"         id="modeFlag">Флаг</button>
    <button class="btn"         id="modePan">Перемещать</button>
  </footer>
</div>

<script>
/* =========================== УТИЛИТЫ ============================ */
const rand = (n)=>Math.floor(Math.random()*n);
const clamp=(x,a,b)=>Math.max(a,Math.min(b,x));
function shuffle(a){for(let i=a.length-1;i>0;i--){const j=rand(i+1);[a[i],a[j]]=[a[j],a[i]];}return a;}
function sample(arr,k){const c=arr.slice();shuffle(c);return c.slice(0,k);}

/* ===================== КОНФИГУРАЦИЯ РАЗМЕРОВ ===================== */
/* Значения подобраны, чтобы солвер быстро находил проходимые поля */
const PRESETS = {
  tri: {
    easy:  {w:22,h:16, mineRatio:0.11},
    norm:  {w:26,h:18, mineRatio:0.13},
    hard:  {w:30,h:20, mineRatio:0.15},
    tileSize: 34
  },
  sq: {
    easy:  {w:14,h:10, mineRatio:0.14},
    norm:  {w:18,h:12, mineRatio:0.17},
    hard:  {w:22,h:14, mineRatio:0.20},
    tileSize: 36
  },
  hex: {
    easy:  {w:16,h:10, mineRatio:0.14},
    norm:  {w:20,h:12, mineRatio:0.17},
    hard:  {w:24,h:14, mineRatio:0.20},
    tileSize: 34
  }
};

/* =================== ГЛОБАЛЬНОЕ СОСТОЯНИЕ ИГРЫ =================== */
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
let W=0,H=0;
let state=null;     // {shape, w,h, mines, cells[], opened, flags}
let view={scale:1, ox:0, oy:0}; // панорамирование/масштаб
let mode='dig';     // 'dig' | 'flag' | 'pan'
let running=false;

/* ====================== ВСПОМОГАТЕЛЬНАЯ МАТЕМАТИКА ===================== */
/* Индексация клеток: i = x + y*w */
const idx=(x,y,w)=>x+y*w;
const inside=(x,y,w,h)=>x>=0&&y>=0&&x<w&&y<h;

/* Соседства для разных тесселяций
   tri: учитываем соседей по РЕБРУ (3 штуки), ориентация зависит от (x+y)%2
   sq : 8-соседей (классика сапёра)
   hex: 6-соседей в «чётно-смещённой» сетке (offset coords)
*/
function neighbors(shape,x,y,w,h){
  const nn=[];
  if(shape==='sq'){
    for(let dy=-1;dy<=1;dy++)for(let dx=0-1;dx<=1;dx++){
      if(dx===0&&dy===0)continue;
      const X=x+dx,Y=y+dy;
      if(inside(X,Y,w,h)) nn.push(idx(X,Y,w));
    }
  }else if(shape==='tri'){
    const up = ((x+y)&1)===0; // чётность — ориентация треугольника
    const candidates = up
      ? [[0,-1],[-1,0],[1,0]]
      : [[0,1],[-1,0],[1,0]];
    for(const [dx,dy] of candidates){
      const X=x+dx,Y=y+dy;
      if(inside(X,Y,w,h)) nn.push(idx(X,Y,w));
    }
  }else if(shape==='hex'){
    // чётно-смещённые ряды («even-q»)
    const even = (y&1)===0;
    const cand = even
      ? [[-1,0],[1,0],[0,-1],[1,-1],[0,1],[1,1]]
      : [[-1,0],[1,0],[-1,-1],[0,-1],[-1,1],[0,1]];
    for(const [dx,dy] of cand){
      const X=x+dx,Y=y+dy;
      if(inside(X,Y,w,h)) nn.push(idx(X,Y,w));
    }
  }
  return nn;
}

/* ========================= ГЕНЕРАЦИЯ ПОЛЯ ========================= */
/* Структура cell: {mine:boolean, n:number, open:boolean, flag:boolean} */
function makeEmpty(w,h){
  return new Array(w*h).fill(0).map(()=>({mine:false,n:0,open:false,flag:false}));
}
function placeMinesRandom(cells,w,h,count){
  const all=[];
  for(let y=0;y<h;y++)for(let x=0;x<w;x++)all.push(idx(x,y,w));
  const mines = sample(all,count);
  for(const i of mines) cells[i].mine=true;
}
function recalcNumbers(shape,cells,w,h){
  for(let y=0;y<h;y++)for(let x=0;x<w;x++){
    const i=idx(x,y,w); if(cells[i].mine){cells[i].n=-1;continue;}
    let c=0; for(const j of neighbors(shape,x,y,w,h)) if(cells[j].mine) c++;
    cells[i].n=c;
  }
}

/* ===================== ЛОГИЧЕСКИЙ СОЛВЕР (ДЕТОКС) ===================== */
/* Базовые правила:
   1) Если цифра = кол-во флагов рядом → открыть все остальные закрытые.
   2) Если цифра = кол-во закрытых рядом → пометить их флажками.
   Также выполняем flood-fill для нулей.
   Генератор перезапускает карту, пока этот солвер не раскроет всё безопасное.
*/
function floodOpen(shape,cells,w,h,start){
  const q=[start]; const seen=new Set([start]);
  while(q.length){
    const i=q.shift(); const x=i%w, y=(i/w)|0;
    cells[i].open=true;
    if(cells[i].n===0){
      for(const j of neighbors(shape,x,y,w,h)){
        if(!seen.has(j) && !cells[j].flag && !cells[j].mine){
          seen.add(j); q.push(j);
        }
      }
    }
  }
}

function logicStep(shape,cells,w,h){
  let changed=false;
  for(let y=0;y<h;y++)for(let x=0;x<w;x++){
    const i=idx(x,y,w), C=cells[i];
    if(!C.open || C.n<=0) continue;
    const adj=neighbors(shape,x,y,w,h);
    const closed=adj.filter(j=>!cells[j].open && !cells[j].flag);
    const flags =adj.filter(j=>cells[j].flag);
    if(flags.length===C.n && closed.length>0){
      // все остальные безопасны
      for(const j of closed){ if(!cells[j].open){ floodOpen(shape,cells,w,h,j); changed=true; } }
    }else if(flags.length+closed.length===C.n && closed.length>0){
      // все закрытые — мины
      for(const j of closed){ if(!cells[j].flag){ cells[j].flag=true; changed=true; } }
    }
  }
  return changed;
}

function isSolved(cells){ return cells.every(c=> c.open || c.mine); }

/* Попытка автосолва карты (копирует массив, не трогает «боевое» состояние) */
function trySolve(shape,cells,w,h){
  const tmp=cells.map(c=>({mine:c.mine,n:c.n,open:false,flag:false}));
  // старт: раскрываем любую безопасную нулевую (или ближайшую к ней)
  // найдём клетку с n==0 (если есть)
  let startIndex = tmp.findIndex(c=>!c.mine && c.n===0);
  if(startIndex<0){
    // нет нулей, откроем случайную безопасную и попытаем счастье
    const safeIdx = tmp.findIndex(c=>!c.mine);
    if(safeIdx>=0) floodOpen(shape,tmp,w,h,safeIdx);
  }else{
    floodOpen(shape,tmp,w,h,startIndex);
  }
  // применяем правила до стагнации
  let guard=0;
  while(guard++<200){
    if(!logicStep(shape,tmp,w,h)) break;
  }
  return isSolved(tmp);
}

/* Сгенерировать поле, пока солвер не пройдёт */
function generateSolvable(shape,w,h,mineCount,maxTries=300){
  for(let t=0;t<maxTries;t++){
    const cells=makeEmpty(w,h);
    placeMinesRandom(cells,w,h,mineCount);
    recalcNumbers(shape,cells,w,h);
    if(trySolve(shape,cells,w,h)) return cells;
  }
  // Если вдруг не удалось — уменьшим количество мин и попробуем ещё
  const less = Math.max(1, Math.floor(mineCount*0.9));
  const cells=makeEmpty(w,h);
  placeMinesRandom(cells,w,h,less);
  recalcNumbers(shape,cells,w,h);
  return cells;
}

/* ============================ РЕНДЕР ============================ */
function resize(){
  canvas.width = canvas.clientWidth = window.innerWidth;
  canvas.height= canvas.clientHeight= window.innerHeight - document.querySelector('header').offsetHeight - document.querySelector('footer').offsetHeight;
  W=canvas.width; H=canvas.height; draw();
}

function worldToScreen(x,y){ return [x*view.scale+view.ox, y*view.scale+view.oy]; }
function screenToWorld(sx,sy){ return [(sx-view.ox)/view.scale, (sy-view.oy)/view.scale]; }

function draw(){
  ctx.clearRect(0,0,W,H);
  if(!state) return;
  const {shape,w,h,cells,size} = state;

  ctx.save();
  ctx.translate(view.ox,view.oy);
  ctx.scale(view.scale,view.scale);

  ctx.lineWidth = 1/Math.max(1,view.scale);

  for(let y=0;y<h;y++)for(let x=0;x<w;x++){
    const i=idx(x,y,w), c=cells[i];
    drawTile(shape,x,y,size, c);
  }
  ctx.restore();
}

function drawTile(shape,x,y,S,c){
  // центр и контур по форме
  let poly=[];
  let cx=0, cy=0;
  if(shape==='sq'){
    cx = x*S*1.05; cy = y*S*1.05;
    poly = squarePoly(cx,cy,S);
  }else if(shape==='hex'){
    const off = (y&1)? S*0.87 : 0;
    cx = x*(S*1.74)+off; cy = y*(S*1.5);
    poly = hexPoly(cx,cy,S*0.95);
  }else{ // tri
    cx = x*(S*0.95); cy = y*(S*0.82);
    const up = ((x+y)&1)===0;
    poly = triPoly(cx,cy,S,up);
  }

  // фон клетки
  ctx.beginPath(); polyPath(poly);
  ctx.fillStyle = c.open ? 'rgba(255,255,255,0.05)' : 'rgba(255,255,255,0.02)';
  ctx.fill();
  ctx.strokeStyle='rgba(255,255,255,0.12)'; ctx.stroke();

  // содержимое
  if(c.flag && !c.open){
    // флаг
    ctx.fillStyle = 'rgba(239,68,68,0.9)';
    drawFlag(cx,cy,Math.max(10,S*0.22));
  }else if(c.open){
    if(c.mine){
      ctx.fillStyle='rgba(239,68,68,0.9)';
      drawMine(cx,cy,Math.max(10,S*0.22));
    }else if(c.n>0){
      ctx.fillStyle='white';
      ctx.font = `${Math.max(10,S*0.38)}px/1.0 ui-monospace,Consolas,monospace`;
      ctx.textAlign='center'; ctx.textBaseline='middle';
      const colorByNum=['#9aa5b1','#22d3ee','#22c55e','#eab308','#ef4444','#a855f7','#f97316','#38bdf8'];
      ctx.fillStyle = colorByNum[(c.n-1)%colorByNum.length];
      ctx.fillText(String(c.n), cx, cy);
    }
  }
}

function polyPath(poly){ ctx.moveTo(poly[0][0],poly[0][1]); for(let k=1;k<poly.length;k++) ctx.lineTo(poly[k][0],poly[k][1]); ctx.closePath(); }
function squarePoly(cx,cy,S){ const r=S*0.48; return [[cx-r,cy-r],[cx+r,cy-r],[cx+r,cy+r],[cx-r,cy+r]]; }
function hexPoly(cx,cy,R){
  const p=[]; for(let k=0;k<6;k++){ const a=Math.PI/3*k; p.push([cx+R*Math.cos(a), cy+R*Math.sin(a)]);} return p;
}
function triPoly(cx,cy,S,up){
  const r=S*0.55, h=r*Math.sqrt(3)/2;
  if(up) return [[cx,cy-h],[cx-r/1.1,cy+h],[cx+r/1.1,cy+h]];
  else   return [[cx,cy+h],[cx-r/1.1,cy-h],[cx+r/1.1,cy-h]];
}
function drawFlag(cx,cy,r){
  ctx.beginPath(); ctx.moveTo(cx-r*0.3,cy+r*0.6); ctx.lineTo(cx-r*0.3,cy-r*0.6); ctx.lineWidth=2/Math.max(1,view.scale); ctx.strokeStyle='rgba(255,255,255,0.8)'; ctx.stroke();
  ctx.beginPath(); ctx.moveTo(cx-r*0.3,cy-r*0.55); ctx.lineTo(cx+r*0.7,cy-r*0.35); ctx.lineTo(cx-r*0.3,cy-r*0.15); ctx.closePath(); ctx.fill();
}
function drawMine(cx,cy,r){
  ctx.beginPath(); ctx.arc(cx,cy,r*0.7,0,Math.PI*2); ctx.fill();
  for(let k=0;k<8;k++){ const a=Math.PI/4*k; ctx.beginPath(); ctx.moveTo(cx,cy); ctx.lineTo(cx+Math.cos(a)*r,cy+Math.sin(a)*r); ctx.strokeStyle='rgba(239,68,68,0.9)'; ctx.lineWidth=2/Math.max(1,view.scale); ctx.stroke(); }
}

/* ============================ ВЗАИМОДЕЙСТВИЕ ============================ */
function cellAtScreen(sx,sy){
  if(!state) return -1;
  const {shape,w,h,size}=state;
  const [wx,wy]=screenToWorld(sx,sy);
  // быстрый поиск по сетке: переберём окрестность
  let best=-1, bestD=1e9;
  for(let y=0;y<h;y++)for(let x=0;x<w;x++){
    // переиспользуем центры как в drawTile
    let cx=0,cy=0;
    if(shape==='sq'){ cx=x*size*1.05; cy=y*size*1.05; }
    else if(shape==='hex'){ const off=(y&1)? size*0.87:0; cx=x*(size*1.74)+off; cy=y*(size*1.5); }
    else { cx=x*(size*0.95); cy=y*(size*0.82); }
    const dx=wx-cx, dy=wy-cy, d=dx*dx+dy*dy;
    if(d<bestD){ bestD=d; best=idx(x,y,state.w); }
  }
  return best;
}

function openCell(i){
  const c=state.cells[i]; if(c.flag||c.open) return;
  if(c.mine){ // проигрыш — откроем все, покажем мины
    state.cells.forEach(cc=>cc.open=true);
    running=false; draw();
    alert('💥 Бум! Попробуй ещё раз — Новая партия гарантированно проходима.');
    return;
  }
  floodOpen(state.shape,state.cells,state.w,state.h,i);
  drawHUD();
  draw();
  checkWin();
}

function toggleFlag(i){
  const c=state.cells[i]; if(c.open) return;
  if(!c.flag && flagsLeft()<=0) return;
  c.flag=!c.flag; drawHUD(); draw();
}

function flagsLeft(){ return state.mines - state.cells.filter(c=>c.flag).length; }
function openedCount(){ return state.cells.filter(c=>c.open).length; }

function checkWin(){
  if(state.cells.every(c=>c.open || c.mine)){
    running=false; draw();
    setTimeout(()=>alert('🎉 Победа!'),10);
  }
}

/* =========== Панорамирование и масштаб (колесо/пинч/перетаскивание) =========== */
canvas.addEventListener('wheel',(e)=>{
  e.preventDefault();
  const scale0=view.scale;
  const delta = -e.deltaY;
  const factor = Math.exp(delta*0.001); // плавно
  const rect=canvas.getBoundingClientRect();
  const cx=e.clientX-rect.left, cy=e.clientY-rect.top;
  zoomAt(cx,cy,factor);
},{passive:false});

let dragging=false, lastX=0,lastY=0;
canvas.addEventListener('pointerdown', (e)=>{
  if(mode==='pan'){ dragging=true; lastX=e.clientX; lastY=e.clientY; canvas.setPointerCapture(e.pointerId); }
});
canvas.addEventListener('pointermove', (e)=>{
  if(dragging){ view.ox += (e.clientX-lastX); view.oy += (e.clientY-lastY); lastX=e.clientX; lastY=e.clientY; draw(); }
});
canvas.addEventListener('pointerup',   ()=>{dragging=false;});

/* Пинч */
let touchIds=[];
let pinchPrevDist=0;
canvas.addEventListener('touchstart', (e)=>{
  if(e.touches.length===2){
    touchIds=[e.touches[0].identifier, e.touches[1].identifier];
    pinchPrevDist = distTouches(e);
  }
},{passive:true});
canvas.addEventListener('touchmove', (e)=>{
  if(e.touches.length===2 && touchIds.every(id=>[...e.touches].some(t=>t.identifier===id))){
    e.preventDefault();
    const d = distTouches(e);
    const factor = d/pinchPrevDist;
    pinchPrevDist=d;
    const rect=canvas.getBoundingClientRect();
    const cx=(e.touches[0].clientX+e.touches[1].clientX)/2-rect.left;
    const cy=(e.touches[0].clientY+e.touches[1].clientY)/2-rect.top;
    zoomAt(cx,cy,factor);
  }
},{passive:false});
function distTouches(e){
  const [a,b]=[e.touches[0],e.touches[1]];
  const dx=a.clientX-b.clientX, dy=a.clientY-b.clientY; return Math.hypot(dx,dy);
}
function zoomAt(cx,cy,factor){
  const prev=view.scale;
  view.scale=clamp(prev*factor,0.5,3.5);
  const [wx,wy]=screenToWorld(cx,cy);
  view.ox = cx - wx*view.scale;
  view.oy = cy - wy*view.scale;
  document.getElementById('zoom').textContent = Math.round(view.scale*100)+'%';
  draw();
}

/* Клики/тапы по полю */
canvas.addEventListener('click',(e)=>{
  if(!running || mode==='pan') return;
  const rect=canvas.getBoundingClientRect();
  const i=cellAtScreen(e.clientX-rect.left,e.clientY-rect.top);
  if(i<0) return;
  if(mode==='dig') openCell(i);
  else if(mode==='flag') toggleFlag(i);
});

/* ====================== UI КНОПКИ И МЕНЮ ====================== */
const mineCountEl=document.getElementById('mineCount');
const flagsLeftEl=document.getElementById('flagsLeft');
const openedEl=document.getElementById('openedCount');
function drawHUD(){
  mineCountEl.textContent = state.mines;
  flagsLeftEl.textContent = flagsLeft();
  openedEl.textContent = openedCount();
}

document.getElementById('modeDig').onclick = ()=>setMode('dig');
document.getElementById('modeFlag').onclick= ()=>setMode('flag');
document.getElementById('modePan').onclick = ()=>setMode('pan');
function setMode(m){
  mode=m;
  document.getElementById('modeDig').dataset.active = (m==='dig')?1:0;
  document.getElementById('modeFlag').dataset.active= (m==='flag')?1:0;
  document.getElementById('modePan').dataset.active = (m==='pan')?1:0;
}

document.getElementById('newBtn').onclick = ()=>{ document.getElementById('menu').style.display='flex'; running=false; };

const shapeGrid=document.getElementById('shapeGrid');
const diffGrid =document.getElementById('diffGrid');
let chosenShape='tri', chosenDiff='easy';
shapeGrid.addEventListener('click',(e)=>{
  const b=e.target.closest('button'); if(!b) return;
  chosenShape=b.dataset.shape;
  [...shapeGrid.children].forEach(x=>x.dataset.active = (x===b)?1:0);
});
diffGrid.addEventListener('click',(e)=>{
  const b=e.target.closest('button'); if(!b) return;
  chosenDiff=b.dataset.diff;
  [...diffGrid.children].forEach(x=>x.dataset.active = (x===b)?1:0);
});

document.getElementById('startBtn').onclick = ()=>{
  startGame(chosenShape, chosenDiff);
  document.getElementById('menu').style.display='none';
};

function startGame(shape,diff){
  const preset = PRESETS[shape];
  const {w,h,mineRatio}=preset[diff];
  const S = preset.tileSize;
  const mines = Math.max(1, Math.floor(w*h*mineRatio));
  const cells = generateSolvable(shape,w,h,mines);
  state={shape,w,h,mines,cells,size:S};
  // сброс вида, центрируем поле
  view.scale=1; view.ox=W/2 - (w* S)*0.4; view.oy=H/2 - (h* S)*0.4;
  running=true; setMode('dig'); drawHUD(); draw();
}

/* ========================= ИНИЦИАЛИЗАЦИЯ ========================= */
resize(); addEventListener('resize', resize);
</script>
</body>
</html>
